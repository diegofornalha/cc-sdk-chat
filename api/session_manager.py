#!/usr/bin/env python3
"""
Gerenciador de Sess√µes - Simples e Claro
Mant√©m sess√µes completamente isoladas
"""

import json
import logging
from pathlib import Path
from typing import Dict, List, Optional, Any
from datetime import datetime
from dataclasses import dataclass

logger = logging.getLogger(__name__)

@dataclass
class Session:
    """Representa uma sess√£o de chat"""
    id: str
    source: str  # 'web' ou 'terminal'
    created_at: str
    last_activity: str
    message_count: int = 0
    file_path: Optional[Path] = None

class SessionManager:
    """
    Gerenciador de Sess√µes Isoladas
    Cada sess√£o √© mantida separada, sem unifica√ß√£o
    """

    # IDs das sess√µes protegidas
    WEB_SESSION = "00000000-0000-0000-0000-000000000001"
    TERMINAL_SESSION = "4b5f9b35-31b7-4789-88a1-390ecdf21559"

    def __init__(self):
        """Inicializa o gerenciador"""
        self.base_path = Path.home() / ".claude" / "projects"
        self.sessions: Dict[str, Session] = {}

        # Inicializa sess√µes protegidas
        self._init_protected_sessions()

        logger.info("‚úÖ SessionManager inicializado")

    def _init_protected_sessions(self):
        """Inicializa as sess√µes protegidas"""
        now = datetime.now().isoformat()

        # Sess√£o Web
        self.sessions[self.WEB_SESSION] = Session(
            id=self.WEB_SESSION,
            source="web",
            created_at=now,
            last_activity=now
        )

        # Sess√£o Terminal
        self.sessions[self.TERMINAL_SESSION] = Session(
            id=self.TERMINAL_SESSION,
            source="terminal",
            created_at=now,
            last_activity=now
        )

        logger.info(f"üåê Sess√£o Web: {self.WEB_SESSION}")
        logger.info(f"üíª Sess√£o Terminal: {self.TERMINAL_SESSION}")

    def is_protected(self, session_id: str) -> bool:
        """Verifica se √© uma sess√£o protegida"""
        return session_id in [self.WEB_SESSION, self.TERMINAL_SESSION]

    def get_session_file(self, session_id: str) -> Optional[Path]:
        """Retorna o arquivo JSONL de uma sess√£o"""
        # Procura em todos os projetos
        for project_dir in self.base_path.iterdir():
            if project_dir.is_dir():
                session_file = project_dir / f"{session_id}.jsonl"
                if session_file.exists():
                    return session_file
        return None

    def read_session(self, session_id: str) -> List[Dict[str, Any]]:
        """L√™ mensagens de uma sess√£o"""
        session_file = self.get_session_file(session_id)

        if not session_file:
            logger.warning(f"Sess√£o n√£o encontrada: {session_id}")
            return []

        messages = []
        try:
            with open(session_file, 'r', encoding='utf-8') as f:
                for line in f:
                    if line.strip():
                        try:
                            msg = json.loads(line)

                            # Filtrar mensagens unificadas em sess√µes protegidas
                            if self.is_protected(session_id):
                                # Pula mensagens unificadas
                                if msg.get("originalSession") or msg.get("unified_at"):
                                    continue

                            messages.append(msg)
                        except json.JSONDecodeError:
                            continue

            logger.info(f"‚úÖ {len(messages)} mensagens lidas de {session_id[:8]}...")

        except Exception as e:
            logger.error(f"‚ùå Erro ao ler sess√£o: {e}")

        return messages

    def write_message(self, session_id: str, message: Dict[str, Any]) -> bool:
        """Escreve mensagem em uma sess√£o"""

        # Bloqueia unifica√ß√£o em sess√µes protegidas
        if self.is_protected(session_id):
            if message.get("originalSession") or message.get("unified_at"):
                logger.warning(f"‚õî Bloqueada tentativa de unificar sess√£o protegida {session_id[:8]}...")
                return False

        # Encontra ou cria arquivo
        session_file = self.get_session_file(session_id)
        if not session_file:
            # Cria no projeto padr√£o
            project_dir = self.base_path / "-Users-2a--claude-cc-sdk-chat-api"
            project_dir.mkdir(parents=True, exist_ok=True)
            session_file = project_dir / f"{session_id}.jsonl"

        try:
            # Adiciona timestamp se n√£o tiver
            if 'timestamp' not in message:
                message['timestamp'] = datetime.now().isoformat()

            # Escreve mensagem
            with open(session_file, 'a', encoding='utf-8') as f:
                f.write(json.dumps(message, ensure_ascii=False) + '\n')

            # Atualiza sess√£o na mem√≥ria
            if session_id in self.sessions:
                self.sessions[session_id].message_count += 1
                self.sessions[session_id].last_activity = datetime.now().isoformat()

            logger.info(f"‚úçÔ∏è Mensagem escrita em {session_id[:8]}...")
            return True

        except Exception as e:
            logger.error(f"‚ùå Erro ao escrever: {e}")
            return False

    def list_sessions(self) -> List[Dict[str, Any]]:
        """Lista todas as sess√µes dispon√≠veis"""
        sessions = []

        # Busca todas as sess√µes em disco
        for project_dir in self.base_path.iterdir():
            if project_dir.is_dir():
                for jsonl_file in project_dir.glob("*.jsonl"):
                    session_id = jsonl_file.stem

                    # Informa√ß√µes b√°sicas
                    session_info = {
                        "id": session_id,
                        "project": project_dir.name,
                        "file": str(jsonl_file),
                        "is_protected": self.is_protected(session_id)
                    }

                    # Detecta origem
                    if session_id == self.WEB_SESSION:
                        session_info["source"] = "web"
                    elif session_id == self.TERMINAL_SESSION:
                        session_info["source"] = "terminal"
                    else:
                        session_info["source"] = "unknown"

                    # Estat√≠sticas
                    try:
                        with open(jsonl_file, 'r') as f:
                            lines = f.readlines()
                            session_info["message_count"] = len(lines)

                            # Pega timestamp da √∫ltima linha
                            if lines:
                                try:
                                    last_msg = json.loads(lines[-1])
                                    session_info["last_activity"] = last_msg.get("timestamp")
                                except:
                                    pass
                    except:
                        session_info["message_count"] = 0

                    sessions.append(session_info)

        # Ordena por √∫ltima atividade
        sessions.sort(key=lambda s: s.get("last_activity", ""), reverse=True)

        logger.info(f"üìã {len(sessions)} sess√µes encontradas")
        return sessions

    def get_session_info(self, session_id: str) -> Dict[str, Any]:
        """Retorna informa√ß√µes detalhadas de uma sess√£o"""
        session_file = self.get_session_file(session_id)

        if not session_file:
            return {"error": "Sess√£o n√£o encontrada"}

        info = {
            "id": session_id,
            "file": str(session_file),
            "project": session_file.parent.name,
            "is_protected": self.is_protected(session_id),
            "source": "unknown"
        }

        # Detecta origem
        if session_id == self.WEB_SESSION:
            info["source"] = "web"
        elif session_id == self.TERMINAL_SESSION:
            info["source"] = "terminal"

        # Estat√≠sticas
        messages = self.read_session(session_id)
        info["message_count"] = len(messages)

        if messages:
            # Primeira e √∫ltima mensagem
            info["first_message"] = messages[0].get("timestamp")
            info["last_message"] = messages[-1].get("timestamp")

            # Conta mensagens por tipo
            user_msgs = sum(1 for m in messages if m.get("type") == "user" or
                          (m.get("message") and m["message"].get("role") == "human"))
            assistant_msgs = sum(1 for m in messages if m.get("type") == "assistant" or
                               (m.get("message") and m["message"].get("role") == "assistant"))

            info["user_messages"] = user_msgs
            info["assistant_messages"] = assistant_msgs

        return info

    def clean_unified_messages(self, session_id: str) -> int:
        """Remove mensagens unificadas de uma sess√£o protegida"""
        if not self.is_protected(session_id):
            logger.warning(f"Sess√£o {session_id[:8]}... n√£o √© protegida")
            return 0

        session_file = self.get_session_file(session_id)
        if not session_file:
            return 0

        clean_messages = []
        removed_count = 0

        try:
            # L√™ todas as mensagens
            with open(session_file, 'r', encoding='utf-8') as f:
                for line in f:
                    if line.strip():
                        try:
                            msg = json.loads(line)

                            # Remove se for unificada
                            if msg.get("originalSession") or msg.get("unified_at"):
                                removed_count += 1
                                logger.debug(f"Removendo mensagem unificada de {msg.get('originalSession', 'unknown')}")
                            else:
                                clean_messages.append(line)
                        except:
                            clean_messages.append(line)

            # Reescreve arquivo limpo
            if removed_count > 0:
                with open(session_file, 'w', encoding='utf-8') as f:
                    f.writelines(clean_messages)

                logger.info(f"üßπ Removidas {removed_count} mensagens unificadas de {session_id[:8]}...")

        except Exception as e:
            logger.error(f"‚ùå Erro ao limpar: {e}")

        return removed_count

    def monitor_protection(self):
        """Monitora e protege sess√µes contra unifica√ß√£o"""
        for session_id in [self.WEB_SESSION, self.TERMINAL_SESSION]:
            removed = self.clean_unified_messages(session_id)
            if removed > 0:
                logger.warning(f"‚ö†Ô∏è Detectada e bloqueada tentativa de unifica√ß√£o em {session_id[:8]}...")

# Inst√¢ncia global
_manager = None

def get_manager() -> SessionManager:
    """Retorna inst√¢ncia global do gerenciador"""
    global _manager
    if _manager is None:
        _manager = SessionManager()
    return _manager